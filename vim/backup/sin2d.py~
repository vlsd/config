import numpy as np


si = 1; # this is the special index: z[si] = phi(z)

def Delta(z):
    return Minv(z)[:,si]/Minv(z)[si,si]

def dDelta(z):
    output = (np.einsum('i,p,pqj,q->ij', Minv(z)[:,si], 
                        Minv(z)[si,:], DM(z), Minv(z)[:,si])/Minv(z)[si,si]**2
                      - np.einsum('ip,pqj,q->ij', Minv(z), DM(z), Minv(z)[:,si])
              /Minv(z)[si,si]) 
    return np.array(output)

# z is the current config to be projected
def P(z, fdiff=False):
    ph = phi(z)
    if ph >= 0 and fdiff == False:
        return z
    else :
        zs = z[si]
        output = copy.deepcopy(z)
        output[si] = -zs
        for i in range(len(z)) :
            if i!= si :
                output[i] = z[i]- Delta(z)[i]*2*zs/(1+k*zs**2) 
        return np.array(output)

# finite differencing of DP, for debugging
def DPdiff(z):
    # let's try some finite differencing and see what happens
    output = np.zeros((len(z),len(z)))
    eps = 1e-7
    for i in range(len(P(z))) :
        for j in range(len(z)) :
            zpertp = copy.deepcopy(z)
            zpertm = copy.deepcopy(z)
            zpertp[j] = z[j]+eps
            zpertm[j] = z[j]-eps
            h = zpertp[j]-zpertm[j]
            output[i,j] = (P(zpertp,fdiff=True)-P(zpertm,fdiff=True))[i]/h
    return np.array(output)

# same as P()       
def DP(z, fdiff=False):
    ph = phi(z)
    if ph > 0 and fdiff==False: 
        print("you shouldn't be calling DP() when phi(z)>0")
        return np.eye(2)
    else :
        output = np.zeros((len(z),len(z)))
        zs = z[si] # the "special index" of z: phi(z) = z[si]
        output[si,si] = -1
        for i in range(len(z)) :
            if i!=si :
                for j in range(len(z)) :
                    if j==i :
                        output[i,j] = 1 - dDelta(z)[i,j]*2*zs/(1+k*zs**2)
                    elif j!=si :
                        output[i,j] = -dDelta(z)[i,j]*2*zs/(1+k*zs**2)
                    else :
                        output[i,j] = -dDelta(z)[i,j]*2*zs/(1+k*zs**2) \
                                - 2*Delta(z)[i]*(1-k*zs**2)/(1+k*zs**2)**2
        return np.array(output)
        #delta = -np.cos(z[0])/(1+np.cos(z[0])**2)
        #Lambda = np.sin(z[0])**3/(1+np.cos(z[0])**2)**2
        #return np.array([[ 1 - 2*z[1]/(1+k*(z[1]**2))*Lambda,
        #                  delta*(2-(2-k)*(z[1]**2))/((1+k*(z[1]**2))**2)],
        #                [0, -1]])# ok i need to figure out what the 
    # derivative of P() is and plop it here. used the fact that 
    # delta= -cos(z[0])/(1+cos(z[0])**2)
    # Lambda = Ddelta = sin(z0)**3/(1+cos(z0)**2)**2

import copy

def D2P(z):
    if phi(z) > 0 :
        print("you shouldn't be calling D2P() when phi(z)>0")
        return np.zeros((2,2,2))
    else :
        output = []
        eps = 1e-7
        for i in range(len(z)) :
            zpertp = copy.deepcopy(z)
            zpertm = copy.deepcopy(z)
            zpertp[i] = z[i]+eps
            zpertm[i] = z[i]-eps
            h = zpertp[i]-zpertm[i]
            output.append((DP(zpertp,fdiff=True)-DP(zpertm,fdiff=True))/h)
        return np.swapaxes(np.swapaxes(np.array(output),0,2), 0,1)

        #s = np.sin(z[0])
        #c = np.cos(z[0])
        #Delta = -np.cos(z[0])/(1+np.cos(z[0])**2)
        #Lambda = np.sin(z[0])**3/(1+np.cos(z[0])**2)**2
        #dDelta = Lambda
        #dLambda = s**2*c*(3+4*s**2*(1+c**2))/(1+c**2)**4
        #return np.array([[[-2*z[1]*dLambda/(1+k*z[1]**2), (2*k*z[1]**2-2)*Lambda/(1+k*z[1]**2)],
        #                  [Lambda*(2-(2-k)*z[1]**2)/(1+k*z[1]**2)**2,
        #                   Delta*(k*(2-k)*z[1]**2-3*k-2)/(1+k*z[1]**2)**3]],
        #                  [[0,0],[0,0]]])

# this extracts the "actual" configuration from the transformed ones
def q(x):
    if len(x) == 4 :  # we are passing in a state
        return Ohm(z(x))
    else :
        raise NameError('wrong length of argument')

# this extracts the configuration from the state
def z(x):
    return x[0 : 2]

def phi(z): 
    return z[si] 

def Dphi(z): 
    return np.array([ 0, 1 ])

def Psi(q):
    return np.array([ q[0], q[1]-np.sin(q[0]) ])

def DPsi(q):
    return np.array([ [1, 0], [-np.cos(q[0]), 1] ])

def Ohm(z):
    return np.array([ z[0], z[1]+np.sin(z[0]) ])

def DOhm(z):
    return np.array([ [1, 0], [np.cos(z[0]), 1] ])

def D2Ohm(z):
    return np.array([ [[0,0], [0,0]], [[-np.sin(z[0]),0], [0,0]] ])

def M(z, mbar=True):
    q = Ohm(z)
    if mbar :
        return np.einsum('pi,pq,qj->ij', DOhm(z), M(q, mbar=False), DOhm(z))
    else :
        return m * np.eye(2)

def Minv(z, mbar=True):
    if mbar:
        q = Ohm(z)
        #return np.dot( DPsi(q).T, np.dot( Minv(z, mbar=False), DPsi(q) ) ) 
        return np.einsum('ip,pq,jq->ij', DPsi(q), Minv(q, mbar=False), DPsi(q))
    else :
        return (1/m) * np.eye(2)

def DM(z, mbar=True):
    if mbar :
        q = Ohm(z)
        return (np.einsum('pik,pq,qj->ijk', D2Ohm(z), M(q, mbar=False), DOhm(z)) 
                + np.einsum('pi,pqk,qj->ijk', DOhm(z), DM(q, mbar=False), DOhm(z))
                + np.einsum('pi,pq,qjk->ijk', DOhm(z), M(q, mbar=False), D2Ohm(z))
               )
    else :
        return np.zeros((2,2,2))

def V(z, bar=True):
    if bar :
        return V(Ohm(z), bar=False)
    else :
        return -m*g*z[1]

def DV(z, bar=True):
    if bar :
        q = Ohm(z)
        return np.dot( DV(q, bar=False), DOhm(z) )
    else :
        return np.array([ 0, -m*g ])

import sys

# the function that defines the dynamics of the system
# depends on M, Minv, P, etc.
def f(t, x):
    z = x[0:2]
    zdot = x[2:4]
    #print( z[1], zdot[0] )
    #sys.exit(0)
    if phi(z) > 0 : 
        # normal dynamics. just inertia and gravity
        #return np.concatenate((zdot, np.array([ 0, -m*g ])))#+ np.sin(z[0])*(zdot[0]**2) ]) ))
        return np.concatenate((zdot, np.dot(Minv(z),  
                               - np.einsum('i,ijk,k', zdot, DM(z), zdot) 
                               + np.einsum('i,ikj,k', zdot, DM(z), zdot )/2
                               + DV(z) ) 
                              ))
        #return np.concatenate((x[2:4], np.dot(Minv(z(x)), 
        #                                      np.dot(DOhm(z(x)).T, 
        #                                             np.array([0, -m*g ])))))
    else :
        zz = P(z)
        zzdot = np.dot(DP(z), zdot)
        DPinv = np.linalg.inv(DP(z))
        return np.concatenate((zdot, np.dot( DPinv, # np.array([ 0, -m*g + np.sin(zz[0])*(zzdot[0]**2) ]) )))
                                        np.dot( Minv(zz),
                               - np.einsum('i,ijk,k', zzdot, DM(zz), zzdot) 
                               + np.einsum('i,ikj,k', zzdot, DM(zz), zzdot )/2
                               + DV(zz) )) - np.einsum('ai,ijk,j,k', DPinv, D2P(z), zdot, zdot)  
                              ))
        #return np.concatenate((x[2:4], np.dot(np.linalg.inv(DP(z(x))), np.dot(Minv(z(x)),
        #                                      np.dot(DOhm(z(x)).T, 
        #                                             np.array([0, -m*g ]))))))

def Df(t, x):
    if phi(z(x)) > 0 :
        return [[0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0], [0, 0, 0, 0]]
    else :
        return [[0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0], [0, 0, 0, 0]]


k = 50
m = 1.0
g = 9.8
qinit = np.array([0,10])
qdoti = np.array([1,-2])
# this line makes an x from the q init values above
init = np.concatenate((Psi(qinit), np.dot(DPsi(qinit), qdoti) ))

from scipy.integrate import ode

solver = ode(f)
solver.set_integrator('vode', max_step=1e-1, min_step=1e-5, method = 'bdf')
solver.set_initial_value(init, 0)
tfinal = 10
dt = 1e-3
t = [0]
x = [init]


while solver.successful() and solver.t < tfinal :
    solver.integrate(tfinal, relax=True, step=True)
    x.append(solver.y);
    t.append(solver.t);
    # check for zero crossing
    gg1 = phi(z(x[-1]))
    gg0 = phi(z(x[-2])) 
    if gg0*gg1 < 0 :
        # find zero crossing
        # interpolate for now
        tcross = t[-2] - gg0*(t[-1]-t[-2])/(gg1-gg0)
        xcross = x[-2] - gg0*(x[-1]-x[-2])/(gg1-gg0)
        # replace wrong x and t
        x[-1] = xcross
        t[-1] = tcross
        # reset integration but switch f
        solver.set_initial_value(xcross, tcross)
        print("found intersection at t=", tcross)
   
import matplotlib.pyplot as plt

# this is for debugging purposes
def iP(z):
    return z

def iOhm(z):
    return z



#plt.plot( [qq[0] for qq in map(Ohm, map(P,map(z, x)))], [np.sin(qq[0]) for qq in map(Ohm, map(P,map(z, x)))])
#plt.plot( [qq[0] for qq in map(Ohm, map(P,map(z, x)))], [qq[1] for qq in map(Ohm, map(P,map(z, x)))],'x-')
plt.plot( [qq[0] for qq in map(iOhm, map(iP,map(z, x)))], [0 for qq in map(iOhm, map(iP,map(z, x)))])
plt.plot( [qq[0] for qq in map(iOhm, map(iP,map(z, x)))], [qq[1] for qq in map(iOhm, map(iP,map(z, x)))], 'x')
plt.axis('equal')
plt.show()
